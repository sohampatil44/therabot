name: Therabot Deployment

on:
  workflow_dispatch:
    inputs:
      stage:
        description: "Deployment stage (dev/prod)"
        required: true
        default: "dev"

jobs:
  deploy:
    name: Deploy to therabot-${{ github.event.inputs.stage }}
    runs-on: ubuntu-latest
    
    env:
      AWS_REGION: us-east-1
      STAGE: ${{ github.event.inputs.stage || 'dev' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}  

      # Install Terraform
      - name: Install Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7

      # Terraform Init (with remote backend)
      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=therabot-terraform-state" \
            -backend-config="key=therabot/terraform.tfstate" \
            -backend-config="region=us-east-1" \
            -backend-config="dynamodb_table=therabot-terraform-lock" \
            -backend-config="encrypt=true"    

      - name: Terraform Plan
        id: terraform_plan
        run: |
          set -e
          terraform plan -out=tfplan \
              -var "stage=${{ github.event.inputs.stage || 'dev' }}" \
              -var-file="terraform.tfvars" \
              -var "github_token=${{ secrets.REPO_ACCESS_TOKEN }}"    

      # Terraform Apply (no DEBUG spam, logs written to file if needed)
      - name: Terraform Apply
        id: terraform_apply
        run: |
          set -e
          terraform apply -auto-approve \
            -var "stage=${{ github.event.inputs.stage || 'dev' }}" \
            -var-file="terraform.tfvars" \
            -var "github_token=${{ secrets.REPO_ACCESS_TOKEN }}" \
            2>&1 | tee terraform-apply.log

      # Save Terraform debug logs as artifact (optional, for troubleshooting)
      - name: Upload Terraform Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-logs
          path: terraform-apply.log

      # Get ALB DNS
      - name: GET ALB DNS
        run: |
          alb_dns=$(terraform output -raw alb_dns_name | tr -d '\r\n')
          echo "ALB_DNS=$alb_dns" >> $GITHUB_ENV

      # Get EC2 public IP   
      - name: Get EC2 public IP
        id: ec2_ip
        run: |
          set -e
          ip=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=techeazy-instance" \
            --query "Reservations[*].Instances[*].PublicIpAddress" \
            --output text | tr -d '\r' | tr -d '\n' | awk '{print $1}')
          if [[ $ip =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "EC2_PUBLIC_IP=$ip" >> $GITHUB_ENV
            echo "ec2_public_ip=$ip" >> $GITHUB_OUTPUT
          else
            echo "::error::Invalid IP address format: $ip"
            exit 1
          fi


      - name: Wait for EC2 SSH
        run: |
          echo "Waiting for EC2 to be ready..."
          sleep 60

      - name: Show App URL
        run: echo "App live on http://${{ env.ALB_DNS }}"

      # Kubernetes Part
      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/$(curl -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Setup SSH to Master Node
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_KEYPAIR_PRIVATE_KEY }}" > ~/.ssh/network-keypair.pem
          chmod 600 ~/.ssh/network-keypair.pem
          
      - name: Fetch kubeconfig from SSM
        run: |
          aws ssm get-parameter \
            --name "/therabot/kubeconfig" \
            --with-decryption \
            --query "Parameter.Value" \
            --output text > kubeconfig
          chmod 600 kubeconfig

      - name: Create namespace if not exists
        run: |
          export KUBECONFIG=./kubeconfig
          if ! kubectl get namespace development >/dev/null 2>&1; then
            kubectl create namespace development
          fi

      - name: Deploy manifests to k3s cluster
        run: |
          export KUBECONFIG=./kubeconfig
          kubectl apply -f k8s/

      - name: Show Kubernetes App URL
        run: echo "Kubernetes app is live on http://${{ steps.ec2_ip.outputs.ec2_public_ip }}:30080"

      - name: Verify Deployment
        run: |
          export KUBECONFIG=./kubeconfig
          kubectl get all -n development
          kubectl get hpa -n development
          kubectl get svc -n development

      # Final Cleanup (Terraform + Kubernetes)
      - name: Cleanup on failure
        if: failure() || cancelled()
        run: |
          echo "Workflow failed or cancelled. Cleaning up resources..."
          
          terraform destroy -auto-approve \
            -var "stage=${{ github.event.inputs.stage || 'dev' }}" \
            -var-file="terraform.tfvars" \
            -var "github_token=${{ secrets.REPO_ACCESS_TOKEN }}"

          export KUBECONFIG=./kubeconfig
          if kubectl get namespace development >/dev/null 2>&1; then
            kubectl delete namespace development --grace-period=0 --force
          fi

      # Always remove kubeconfig file
      - name: Remove kubeconfig
        if: always()
        run: rm -f ./kubeconfig
