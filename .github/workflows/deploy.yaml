name: Therabot Deployment

on:
  workflow_dispatch:
    inputs:
      stage:
        description: "Deployment stage (dev/prod)"
        required: true
        default: "dev"

jobs:
  deploy:
    name: Deploy to therabot-${{ github.event.inputs.stage }}
    runs-on: ubuntu-latest
    
    env:
      AWS_REGION: us-east-1
      STAGE: ${{ github.event.inputs.stage || 'dev' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}  

      # Install Terraform
      - name: Install Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7

      # Terraform Init (with remote backend)
      - name: Terraform Init
        run: |
          terraform init \
            -backend-config="bucket=therabot-terraform-state" \
            -backend-config="key=therabot/terraform.tfstate" \
            -backend-config="region=us-east-1" \
            -backend-config="dynamodb_table=therabot-terraform-lock" \
            -backend-config="encrypt=true"

      # Terraform Plan
      - name: Terraform Plan
        id: terraform_plan
        run: |
          set -e
          terraform plan -out=tfplan \
            -var "stage=${{ github.event.inputs.stage || 'dev' }}" \
            -var-file="terraform.tfvars" \
            -var "github_token=${{ secrets.REPO_ACCESS_TOKEN }}"

      # Terraform Apply
      - name: Terraform Apply
        id: terraform_apply
        run: |
          set -e
          terraform apply -auto-approve \
            -var "stage=${{ github.event.inputs.stage || 'dev' }}" \
            -var-file="terraform.tfvars" \
            -var "github_token=${{ secrets.REPO_ACCESS_TOKEN }}" \
            2>&1 | tee terraform-apply.log

      # Upload Terraform logs
      - name: Upload Terraform Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: terraform-logs
          path: terraform-apply.log

      # Get ALB DNS safely
      - name: GET ALB DNS
        run: |
          alb_dns=$(terraform output -raw alb_dns_name 2>/dev/null | tr -d '\r\n')
          if [ -z "$alb_dns" ]; then
            echo "::error::ALB DNS is empty"
            exit 1
          fi
          echo "ALB_DNS=$alb_dns" >> $GITHUB_ENV

      # Get therabot ASG instance public IP (the one connected to ALB)
      - name: Get EC2 public IP
        id: ec2_ip
        run: |
          set -e
          
          echo "Getting public IP from therabot-asg instances (connected to ALB)..."
          
          # Get IP from therabot-asg instances only
          ip=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=therabot-asg" "Name=instance-state-name,Values=running" \
            --query "Reservations[*].Instances[*].PublicIpAddress" \
            --output text | tr -d '\r\n' | awk 'NF && $1!="None" {print $1; exit}')
          
          # Validate IP format
          if [[ $ip =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "EC2_PUBLIC_IP=$ip" >> $GITHUB_ENV
            echo "ec2_public_ip=$ip" >> $GITHUB_OUTPUT
            echo "Successfully found therabot-asg instance IP: $ip"
          else
            echo "::error::Could not find valid therabot-asg instance IP address: '$ip'"
            
            # Debug: Show therabot ASG information
            echo "Debug: Therabot ASG instances:"
            aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=therabot-asg" \
              --query "Reservations[*].Instances[*].[InstanceId,Tags[?Key=='Name'].Value|[0],PublicIpAddress,PrivateIpAddress,State.Name]" \
              --output table
            
            echo "Debug: ASG details:"
            aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names "therabot-asg" \
              --query "AutoScalingGroups[*].[AutoScalingGroupName,DesiredCapacity,MinSize,MaxSize,Instances[*].[InstanceId,HealthStatus,LifecycleState]]" \
              --output table
            
            exit 1
          fi

      - name: Show App URL
        run: echo "App live on http://${{ env.ALB_DNS }}"

      # Kubernetes setup - FIXED kubectl installation
      - name: Install kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Setup SSH to Master Node
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_KEYPAIR_PRIVATE_KEY }}" > ~/.ssh/network-keypair.pem
          chmod 600 ~/.ssh/network-keypair.pem

      # FIXED: Wait for k3s cluster to be fully initialized before fetching kubeconfig
      - name: Wait for k3s cluster initialization
        run: |
          echo "Waiting for k3s master node to complete initialization..."
          timeout=900  # 15 minutes timeout
          elapsed=0
          interval=30
          
          while [ $elapsed -lt $timeout ]; do
            echo "Checking if k3s cluster is initialized... ($elapsed/${timeout}s)"
            
            # Check if kubeconfig exists in SSM and has the correct server IP
            kubeconfig_content=$(aws ssm get-parameter \
              --name "/therabot/kubeconfig" \
              --with-decryption \
              --query "Parameter.Value" \
              --output text 2>/dev/null || echo "")
            
            if [ -n "$kubeconfig_content" ]; then
              # Check if kubeconfig has been updated with actual IP (not localhost)
              if echo "$kubeconfig_content" | grep -q "server: https://127.0.0.1:6443"; then
                echo "â³ Kubeconfig still has localhost IP, waiting for master to update it..."
              else
                echo "âœ… Kubeconfig has been updated with proper IP!"
                
                # Also verify the master IP is reachable
                master_ip=$(echo "$kubeconfig_content" | grep "server:" | sed 's/.*https:\/\/\([^:]*\):.*/\1/')
                if curl -k --connect-timeout 10 https://${master_ip}:6443/healthz >/dev/null 2>&1; then
                  echo "âœ… k3s API server is responding at ${master_ip}!"
                  break
                else
                  echo "â³ k3s API server at ${master_ip} not ready yet..."
                fi
              fi
            else
              echo "â³ Kubeconfig not found in SSM yet, waiting..."
            fi
            
            sleep $interval
            elapsed=$((elapsed + interval))
          done
          
          if [ $elapsed -ge $timeout ]; then
            echo "::error::âŒ Timeout waiting for k3s cluster to initialize"
            
            # Debug information
            echo "Debug: Checking master node status:"
            aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=k3s-master" "Name=instance-state-name,Values=running" \
              --query "Reservations[*].Instances[*].[InstanceId,State.Name,PublicIpAddress,PrivateIpAddress]" \
              --output table
            
            # Try to get current kubeconfig content for debugging
            echo "Debug: Current kubeconfig in SSM:"
            aws ssm get-parameter \
              --name "/therabot/kubeconfig" \
              --with-decryption \
              --query "Parameter.Value" \
              --output text 2>/dev/null | head -10 || echo "No kubeconfig found"
            
            exit 1
          fi
          
      - name: Fetch kubeconfig from SSM
        run: |
          echo "Fetching kubeconfig from SSM..."
          aws ssm get-parameter \
            --name "/therabot/kubeconfig" \
            --with-decryption \
            --query "Parameter.Value" \
            --output text > kubeconfig
          chmod 600 kubeconfig
          
          # Validate kubeconfig file
          if [ ! -s kubeconfig ]; then
            echo "::error::kubeconfig file is empty or not found"
            exit 1
          fi
          
          # Show kubeconfig server (for debugging, but redacted)
          echo "Kubeconfig server endpoint:"
          grep "server:" kubeconfig

      - name: Verify k3s cluster connectivity
        run: |
          echo "Verifying k3s cluster connectivity..."
          export KUBECONFIG=./kubeconfig
          
          # Test cluster connectivity
          if kubectl cluster-info >/dev/null 2>&1; then
            echo "âœ… k3s cluster is accessible!"
            kubectl version --short
            kubectl get nodes
          else
            echo "::error::âŒ Failed to connect to k3s cluster"
            echo "Debug: kubeconfig content (redacted):"
            grep -E "server:|name:" kubeconfig || true
            exit 1
          fi

      - name: Create namespace if not exists
        run: |
          export KUBECONFIG=./kubeconfig
          echo "Creating development namespace if it doesn't exist..."
          
          if ! kubectl get namespace development >/dev/null 2>&1; then
            kubectl create namespace development
            echo "âœ… Created development namespace"
          else
            echo "âœ… Development namespace already exists"
          fi

      - name: Validate k8s manifests
        run: |
          export KUBECONFIG=./kubeconfig
          echo "Validating Kubernetes manifests..."
          
          # Check if k8s directory exists and has files
          if [ ! -d "k8s" ] || [ -z "$(ls -A k8s 2>/dev/null)" ]; then
            echo "::error::k8s directory is empty or doesn't exist"
            exit 1
          fi
          
          echo "Found manifest files:"
          ls -la k8s/
          
          # Dry-run to validate manifests
          kubectl apply -f k8s/ --dry-run=client --namespace=development

      - name: Deploy manifests to k3s cluster
        run: |
          export KUBECONFIG=./kubeconfig
          echo "Deploying manifests to k3s cluster..."
          
          # Apply manifests
          kubectl apply -f k8s/ --namespace=development
          
          echo "Waiting for deployments to be ready..."
          
          # Wait for deployments with timeout
          for deploy in $(kubectl get deployments -n development -o name 2>/dev/null || true); do
            if [ -n "$deploy" ]; then
              echo "Waiting for $deploy to be ready..."
              kubectl rollout status $deploy -n development --timeout=300s
            fi
          done
          
          echo "âœ… All deployments are ready!"

      - name: Show Kubernetes App URL
        run: |
          echo "ðŸš€ Kubernetes app is live on http://${{ steps.ec2_ip.outputs.ec2_public_ip }}:30080"

      - name: Verify Deployment
        run: |
          export KUBECONFIG=./kubeconfig
          echo "=== Deployment Verification ==="
          
          echo "ðŸ“‹ All resources in development namespace:"
          kubectl get all -n development
          
          echo ""
          echo "ðŸ“ˆ Horizontal Pod Autoscalers:"
          kubectl get hpa -n development 2>/dev/null || echo "No HPA found"
          
          echo ""
          echo "ðŸ”— Services:"
          kubectl get svc -n development
          
          echo ""
          echo "ðŸ“Š Pod status:"
          kubectl get pods -n development -o wide

      # Cleanup on failure
      - name: Cleanup on failure
        if: failure() || cancelled()
        run: |
          echo "ðŸ§¹ Workflow failed or cancelled. Cleaning up resources..."
          
          # Cleanup k3s resources
          if [ -f kubeconfig ]; then
            export KUBECONFIG=./kubeconfig
            if kubectl get namespace development >/dev/null 2>&1; then
              echo "Deleting development namespace..."
              kubectl delete namespace development --grace-period=30 --timeout=120s || true
            fi
          fi
          
          # Cleanup Terraform resources
          echo "Destroying Terraform infrastructure..."
          terraform destroy -auto-approve \
            -var "stage=${{ github.event.inputs.stage || 'dev' }}" \
            -var-file="terraform.tfvars" \
            -var "github_token=${{ secrets.REPO_ACCESS_TOKEN }}" || true

      # Always remove kubeconfig
      - name: Remove kubeconfig
        if: always()
        run: |
          echo "ðŸ”’ Cleaning up kubeconfig..."
          rm -f ./kubeconfig